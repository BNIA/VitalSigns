# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/RBIntel.ipynb (unless otherwise specified).

__all__ = ['vsDom', 'cashsa', 'reosa']

# Cell
import numpy as np
import pandas as pd
# import geopandas
import geopandas as gpd
# from geopandas import GeoDataFrame

# Cell
def vsDom(df, yr):
  id = '30'
  shortname = 'dom'
  fincol = id+'-'+shortname+year

  # Create the Numerator and Denominator
  numer = df[['DaysonMark','CSA2010']].copy()

  # Filter Em
  numer = numer[ numer['DaysonMark'] > 0]
  print( numer.shape[0] )

  # Get Bcity Val
  bCityVal = numer.median(numeric_only=True)['DaysonMark']

  # Group by CSA
  numer = numer.groupby('CSA2010').median(numeric_only=True) # use .median to calculate DOM.

  # Make sure ALL csas and BaltimoreCity are included and sorted.
  numer = csa.merge( numer, left_on='CSA2010', right_on='CSA2010', how='outer' )
  numer.drop( columns=['geometry', 'Shape__Length','Shape__Area', 'OBJECTID', 'tpop10'], inplace=True)

  # Bcity is the median of all the records an not the community medians.
  # Incorrect Bcity median IFF Groupby keeps a 'False' row (index 56)
  numer.at[55,'DaysonMark']= bCityVal

  # Perform the calculation
  numer[fincol] = numer['DaysonMark']

  compareYears = gpd.read_file("https://services1.arcgis.com/mVFRs7NF4iFitgbY/ArcGIS/rest/services/"+shortname.capitalize()+"/FeatureServer/0/query?where=1%3D1&outFields=*&returnGeometry=true&f=pgeojson");
  goback = 2 if year == '19' else 3 if year == '20' else 1
  prevYear = shortname + str( int(year) - goback )
  if prevYear in compareYears.columns:
    numer = numer.merge( compareYears[['CSA2010', prevYear]], left_on='CSA2010', right_on='CSA2010', how='outer' )
    numer['change'] = numer[id+'-'+shortname+year] - numer[ prevYear ]
    numer['percentChange'] = numer['change' ] / numer[ prevYear ] * 100
    numer['change'] = numer['change'].apply(lambda x: "{:.2f}".format(x) )
    print( 'Records Matching Query: ', numer.size / len(numer.columns) )

  return numer

# Cell
def cashsa(df, yr):
  id = '38'
  shortname = 'cashsa'
  fincol = id+'-'+shortname+year

  # Create the Numerator and Denominator
  numer = df[['BuyerFinan','CSA2010']].copy()
  numer['count'] = 1
  denom = numer.copy()

  # Filter Em
  numer = numer[ numer['BuyerFinan'].str.contains('.Cash.|.Cash|Cash.|Cash', regex=True, na=False) ]
  print("LENGTH AFTER FILTER: ", len(numer) )

  # Get Bcity Val
  bCityVal = numer.sum(numeric_only=True)['count']
  bCityValDenom = denom.sum(numeric_only=True)['count']

  # Group by CSA
  numer = numer.groupby('CSA2010').sum(numeric_only=True)
  denom = denom.groupby('CSA2010').sum(numeric_only=True)

  # Make sure ALL csas and BaltimoreCity are included and sorted.
  numer = csa.merge( numer, left_on='CSA2010', right_on='CSA2010', how='outer' )
  numer.drop( columns=['geometry', 'Shape__Length','Shape__Area', 'OBJECTID', 'tpop10'], inplace=True)

  denom = csa.merge( denom, left_on='CSA2010', right_on='CSA2010', how='outer' )
  denom.drop( columns=['geometry', 'Shape__Length','Shape__Area', 'OBJECTID', 'tpop10'], inplace=True)

  # Bcity is the sum of the community sums.
  # Incorrect Bcity Sum IFF Groupby keeps a 'False' row (index 56)
  numer.at[55,'count']= bCityVal
  denom.at[55,'count']= bCityValDenom

  # Perform the calculation
  numer[fincol] = numer['count'] / denom['count'] * 100

  compareYears = gpd.read_file("https://services1.arcgis.com/mVFRs7NF4iFitgbY/ArcGIS/rest/services/"+shortname.capitalize()+"/FeatureServer/0/query?where=1%3D1&outFields=*&returnGeometry=true&f=pgeojson");
  goback = 2 if year == '19' else 3 if year == '20' else 1
  prevYear = shortname + str( int(year) - goback )
  if prevYear in compareYears.columns:
    numer = numer.merge( compareYears[['CSA2010', prevYear]], left_on='CSA2010', right_on='CSA2010', how='outer' )
    numer['change'] = numer[id+'-'+shortname+year] - numer[ prevYear ]
    numer['percentChange'] = numer['change' ] / numer[ prevYear ] * 100
    numer['change'] = numer['change'].apply(lambda x: "{:.2f}".format(x) )
    print( 'Records Matching Query: ', numer.size / len(numer.columns) )

  return numer

# Cell
def reosa(df, yr):
  id = '39'
  shortname = 'reosa'
  fincol = id+'-'+shortname+year

  # Create the Numerator and Denominator
  numer = df[['Foreclosur','CSA2010']].copy()
  numer['count'] = 1

  denom = numer.copy()
  denom['count'] = 1

  # Filter Em
  numer = numer[ numer['Foreclosur'].str.contains('.Y.|.Y|Y.|Y', regex=True, na=False) ]
  print( numer['Foreclosur'].value_counts() )

  # Get Bcity Val
  bCityVal = numer.sum(numeric_only=True)['count']
  bCityValDenom = denom.sum(numeric_only=True)['count']

  # Group by CSA
  numer = numer.groupby('CSA2010').sum(numeric_only=True)
  denom = denom.groupby('CSA2010').sum(numeric_only=True)

  # Make sure ALL csas and BaltimoreCity are included and sorted.
  numer = csa.merge( numer, left_on='CSA2010', right_on='CSA2010', how='outer' )
  numer.drop( columns=['geometry', 'Shape__Length','Shape__Area', 'OBJECTID', 'tpop10'], inplace=True)

  denom = csa.merge( denom, left_on='CSA2010', right_on='CSA2010', how='outer' )
  denom.drop( columns=['geometry', 'Shape__Length','Shape__Area', 'OBJECTID', 'tpop10'], inplace=True)

  # Bcity is the sum of the community sums.
  # Incorrect Bcity Sum IFF Groupby keeps a 'False' row (index 56)
  numer.at[55,'count']= bCityVal
  denom.at[55,'count']= bCityValDenom

  # Perform the calculation
  numer['denomCount'] = denom['count']
  numer[fincol] = numer['count'] / numer['denomCount'] * 100

  compareYears = gpd.read_file("https://services1.arcgis.com/mVFRs7NF4iFitgbY/ArcGIS/rest/services/"+shortname.capitalize()+"/FeatureServer/0/query?where=1%3D1&outFields=*&returnGeometry=true&f=pgeojson");
  goback = 2 if year == '19' else 3 if year == '20' else 1
  prevYear = shortname + str( int(year) - goback )
  if prevYear in compareYears.columns:
    numer = numer.merge( compareYears[['CSA2010', prevYear]], left_on='CSA2010', right_on='CSA2010', how='outer' )
    numer['change'] = numer[id+'-'+shortname+year] - numer[ prevYear ]
    numer['percentChange'] = numer['change' ] / numer[ prevYear ] * 100
    numer['change'] = numer['change'].apply(lambda x: "{:.2f}".format(x) )
    print( 'Records Matching Query: ', numer.size / len(numer.columns) )

  return numer